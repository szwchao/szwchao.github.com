<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>c语言 | wchao</title>
  <meta name="author" content="wchao">
  
  <meta name="description" content="字节对齐1234567891011121314151617// 第一种struct A&amp;#123;    char a;    short b;    int c;&amp;#125;;sizeof(struct A) = 8;// 第二种struct A&amp;#123;    char a;    int c;    short b;&amp;#125;;sizeof(struct A) = 12;">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="c语言"/>
  <meta property="og:site_name" content="wchao"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.ico" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">wchao</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="文章归档">
			  <i class="fa fa-archive"></i>归档
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="文章分类">
			  <i class="fa fa-folder"></i>分类
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="所有标签">
			  <i class="fa fa-tags"></i>标签
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="我的足迹">
			  <i class="fa fa-user"></i>关于
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">		
			<h1> c语言</h1>
		</div>		
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h3 id="u5B57_u8282_u5BF9_u9F50"><a href="#u5B57_u8282_u5BF9_u9F50" class="headerlink" title="字节对齐"></a>字节对齐</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">struct</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> A) = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">struct</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> A) = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>看图</p>
<p><img src="/images/c_align.jpg" alt="对齐"></p>
<h2 id="u6307_u9488"><a href="#u6307_u9488" class="headerlink" title="指针"></a>指针</h2><h3 id="u6307_u9488_u7C7B_u578B"><a href="#u6307_u9488_u7C7B_u578B" class="headerlink" title="指针类型"></a>指针类型</h3><table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int p;</code></td>
<td>一个整型变量</td>
</tr>
<tr>
<td><code>int *p;</code></td>
<td>一个指向整型数的指针</td>
</tr>
<tr>
<td><code>int p[10];</code></td>
<td>一个有10个整型数的数组</td>
</tr>
<tr>
<td><code>int *p[10];</code></td>
<td>一个有10个指针的数组，该指针是指向一个整型数的</td>
</tr>
<tr>
<td><code>int (*p)[10];</code></td>
<td>一个指向有10个整型数数组的指针</td>
</tr>
<tr>
<td><code>int **p;</code></td>
<td>一个指向指针的的指针，它指向的指针是指向一个整型数</td>
</tr>
<tr>
<td><code>int p(int);</code></td>
<td>一个有整型参数且返回类型为整型的函数</td>
</tr>
<tr>
<td><code>int (*p)(int);</code></td>
<td>一个指向函数的指针，该函数有一个整型参数并返回一个整型数</td>
</tr>
<tr>
<td><code>int (*p[10])(int);</code></td>
<td>一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数</td>
</tr>
</tbody>
</table>
<h3 id="u6307_u9488_u8FD0_u7B97"><a href="#u6307_u9488_u8FD0_u7B97" class="headerlink" title="指针运算"></a>指针运算</h3><h4 id="u8FD0_u7B97_u7B26_26amp_3B_u548C*"><a href="#u8FD0_u7B97_u7B26_26amp_3B_u548C*" class="headerlink" title="运算符&amp;和*"></a>运算符&amp;和*</h4><p><code>&amp;</code>是取地址运算符</p>
<p><code>*</code>是书上叫做<strong>间接运算符</strong></p>
<h4 id="u6307_u9488_u957F_u5EA6"><a href="#u6307_u9488_u957F_u5EA6" class="headerlink" title="指针长度"></a>指针长度</h4><p>在32位系统中，指针只代表指向的值的<strong>地址</strong>，所以其本身的长度为4个字节，可以用<strong>sizeof()</strong>得出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line"><span class="keyword">struct</span> xx *p;</span><br></pre></td></tr></table></figure>
<p>不管哪个，<strong>sizeof(p)=4</strong>！</p>
<h4 id="u6307_u9488_u8FD0_u7B97-1"><a href="#u6307_u9488_u8FD0_u7B97-1" class="headerlink" title="指针运算"></a>指针运算</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p++;</span><br></pre></td></tr></table></figure>
<p>p指向下一个单元地址，也就是把指针p的值加上了sizeof(int)，根据p指向的变量不同而不同。32位系统中，int占用4个字节，所以p的地址会加<strong>4</strong></p>
<div class="alert alert-danger"><i class="fa fa-bug"></i>  注意：指针运算时是按p的类型长度，而不是赋值时的变量长度</div>
<h3 id="u6307_u9488_u548C_u6570_u7EC4"><a href="#u6307_u9488_u548C_u6570_u7EC4" class="headerlink" title="指针和数组"></a>指针和数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>一般而言，数组名可以看做指针，指向数组的第0个单元。</p>
<p>array+3是一个指向数组第3个单元的指针，所以*(array+3)等于3。</p>
<div class="alert alert-danger"><i class="fa fa-bug"></i>  与指针不同的是，数组名只能代表数组首地址，并不是一个变量，所以不是一个左值，并不能进行如 `array++` 这样的运算。</div>
<p>关于sizeof</p>
<ul>
<li><code>sizeof(array)</code> 数组的大小， =40    （sizeof(int)*10）</li>
<li><code>sizeof(*array)</code>  数组单元的大小， =4 （sizeof(int))</li>
<li><code>sizeof(array+1)</code> 指针类型的大小， =4 （指针本身的长度，32位系统为4）</li>
</ul>
<h3 id="u6307_u9488_u548C_u7ED3_u6784"><a href="#u6307_u9488_u548C_u7ED3_u6784" class="headerlink" title="指针和结构"></a>指针和结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> MyStruct </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">int</span> a; </span><br><span class="line">    <span class="keyword">int</span> b; </span><br><span class="line">    <span class="keyword">int</span> c; </span><br><span class="line">&#125; </span><br><span class="line">MyStruct ss=&#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;     <span class="comment">//声明了结构对象ss，并把ss的三个成员初始化为20，30和40。</span></span><br><span class="line">MyStruct *ptr=&amp;ss;          <span class="comment">//声明了一个指向结构对象ss的指针。它的类型是MyStruct*,它指向的类型是MyStruct。</span></span><br><span class="line"><span class="keyword">int</span> *pstr=(<span class="keyword">int</span>*)&amp;ss;        <span class="comment">//声明了一个指向结构对象ss的指针。但是它的类型和它指向的类型和ptr是不同的。</span></span><br></pre></td></tr></table></figure>
<p>请问怎样通过指针ptr来访问ss的三个成员变量？</p>
<p>答案： </p>
<blockquote>
<p>ptr-&gt;a;<br>ptr-&gt;b;<br>ptr-&gt;c; </p>
</blockquote>
<h3 id="u6307_u9488_u548C_u51FD_u6570"><a href="#u6307_u9488_u548C_u51FD_u6570" class="headerlink" title="指针和函数"></a>指针和函数</h3><hr>
<h2 id="u94FE_u8868"><a href="#u94FE_u8868" class="headerlink" title="链表"></a>链表</h2><h3 id="C_u8BED_u8A00_u94FE_u8868_u7684_u4F5C_u7528_uFF1A"><a href="#C_u8BED_u8A00_u94FE_u8868_u7684_u4F5C_u7528_uFF1A" class="headerlink" title="C语言链表的作用："></a>C语言链表的作用：</h3><ul>
<li>实现内存的动态分配</li>
<li>实现内存数据的不连续存储</li>
</ul>
<h3 id="C_u8BED_u8A00_u94FE_u8868_u7684_u6784_u6210"><a href="#C_u8BED_u8A00_u94FE_u8868_u7684_u6784_u6210" class="headerlink" title="C语言链表的构成"></a>C语言链表的构成</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> node</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> a;</span><br><span class="line">   <span class="keyword">struct</span> node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链表是由节点组成，所谓节点就是指一个结构体，这个结构体主要包括两部分：<strong>数据域</strong> 和 <strong>指针域</strong>。指针域用来指向下一个节点的首地址。</p>
<p>首节点：</p>
<p>尾节点：尾节点指针域指向NULL。</p>
<h3 id="u94FE_u8868_u7684_u5206_u7C7B"><a href="#u94FE_u8868_u7684_u5206_u7C7B" class="headerlink" title="链表的分类"></a>链表的分类</h3><p>链表主要分为三种：单链表；双链表；循环链表</p>
<h3 id="u94FE_u8868_u7684_u64CD_u4F5C"><a href="#u94FE_u8868_u7684_u64CD_u4F5C" class="headerlink" title="链表的操作"></a>链表的操作</h3><p>链表的操作主要包括：</p>
<ul>
<li>链表的创建</li>
<li>链表的删除</li>
<li>链表的插入</li>
</ul>
<p>下面以单链表为例讲述这三种链表的操作：</p>
<ul>
<li>链表的创建</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> chain</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> value;           <span class="comment">//数据域</span></span><br><span class="line">   <span class="keyword">struct</span> chain *next;  <span class="comment">//指针域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> chain *<span class="title">create</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">struct</span> chain *head,*tail,*p;     <span class="comment">//头节点、尾节点、创建节点</span></span><br><span class="line">   <span class="keyword">int</span> x;</span><br><span class="line">   head=tail=<span class="literal">NULL</span>;                  <span class="comment">//指针初始化NULL</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Input data \n"</span>);</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x)==<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      p=(<span class="keyword">struct</span> chain *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> chain));</span><br><span class="line">      p-&gt;value=x;</span><br><span class="line">      p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//初始链表里没有元素时</span></span><br><span class="line">          head=tail=p;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">// 又有一个了</span></span><br><span class="line">         tail=tail-&gt;next;           <span class="comment">//把尾部指向上一个</span></span><br><span class="line">         tail-&gt;next=p;              <span class="comment">//把p挂在最后面，变成新的尾部</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">struct</span> chain *p,*q;</span><br><span class="line">   q=creat();</span><br><span class="line">   <span class="keyword">while</span>(q)</span><br><span class="line">   &#123;</span><br><span class="line">      p=q-&gt;next;</span><br><span class="line">      <span class="built_in">free</span>(q);</span><br><span class="line">      q=p;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>链表的删除，本例是删除数据域为a的链表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">struct</span> chain *<span class="title">DelNode</span><span class="params">(head,a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">struct</span> chain *p,*q;</span><br><span class="line">   <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">   &#123;<span class="built_in">printf</span>(<span class="string">"this is a Empty link!"</span>)&#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(head-&gt;value==a)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">//如果是第一个</span></span><br><span class="line">      p=head;</span><br><span class="line">      head=head-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      p=head;</span><br><span class="line">      <span class="keyword">while</span>((p-&gt;value!=a)&amp;&amp;(p-&gt;next!=<span class="literal">NULL</span>))</span><br><span class="line">      &#123;</span><br><span class="line">         q=p;           <span class="comment">//找到时，q是上一个</span></span><br><span class="line">         p=p-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;value==a)</span><br><span class="line">      &#123;</span><br><span class="line">         p=p-&gt;next;     <span class="comment">//p是要找的，此时将p指向下一个，准备清空找到的这个</span></span><br><span class="line">         q-&gt;next=p;     <span class="comment">//上一个的下一个指向p，其实就是把中间一个跳过去了</span></span><br><span class="line">         <span class="built_in">free</span>(p);       <span class="comment">//释放的哪一个？？？</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>链表的插入</li>
</ul>
<p>链表的插入分三种情况：将节点插到链表的头；将节点插到链表的中间；将节点插到链表的尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> chain</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> value;           <span class="comment">//数据域</span></span><br><span class="line">   <span class="keyword">struct</span> chain *next;  <span class="comment">//指针域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> chain *<span class="title">insertNode</span><span class="params">(head,a,b)</span>   <span class="comment">//head为头节点，a,b均为数据域,a为插入地方的节点数据域，b为新插入节点的数据域</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">struct</span> chain *p,*q,*s;</span><br><span class="line">   s=(<span class="keyword">struct</span> chain *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> chain));</span><br><span class="line">   s-&gt;value=b;</span><br><span class="line">   <span class="keyword">if</span>(head==<span class="literal">NULL</span>)       <span class="comment">//判断链表是否为空链表</span></span><br><span class="line">   &#123;</span><br><span class="line">      head=s;</span><br><span class="line">      s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(head-&gt;value==a)</span><br><span class="line">   &#123;</span><br><span class="line">      s-&gt;next=head;</span><br><span class="line">      head=s;           <span class="comment">//head头节点变为s，head原来的值被s链接。</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      p=head;</span><br><span class="line">      <span class="keyword">while</span>((p-&gt;value!=a)&amp;&amp;(p-&gt;next!=<span class="literal">NULL</span>))</span><br><span class="line">      &#123;</span><br><span class="line">         q=p;</span><br><span class="line">         p=p-&gt;next;</span><br><span class="line">      &#125; <span class="comment">//用循环进行链表的移动</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;value==a)</span><br><span class="line">      &#123;</span><br><span class="line">         s-&gt;next=p;</span><br><span class="line">         q-&gt;next=s;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//将节点插入到链表的末尾</span></span><br><span class="line">      &#123;</span><br><span class="line">         p-&gt;next=s;</span><br><span class="line">         s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">      &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="u6392_u5E8F"><a href="#u6392_u5E8F" class="headerlink" title="排序"></a>排序</h2><h3 id="u5192_u6CE1_u6392_u5E8F"><a href="#u5192_u6CE1_u6392_u5E8F" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*================================================</span><br><span class="line">  功能：冒泡排序</span><br><span class="line">  输入：数组名称（也就是数组首地址）、数组中元素个数</span><br><span class="line">  ================================================*/</span></span><br><span class="line"><span class="comment">/*====================================================</span><br><span class="line">  算法思想简单描述：</span><br><span class="line"></span><br><span class="line">  在要排序的一组数中，对当前还未排好序的范围内的全部数，自上</span><br><span class="line">  而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较</span><br><span class="line">  小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要</span><br><span class="line">  求相反时，就将它们互换。</span><br><span class="line"></span><br><span class="line">  冒泡排序是稳定的。算法时间复杂度O(n2)--[n的平方]</span><br><span class="line">  =====================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buble_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i,j,k;</span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n; j++)   <span class="comment">/* 气泡法要排序n次*/</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n-j; i++)  <span class="comment">/* 值比较大的元素沉下去后，只把剩下的元素中的最大值再沉下去就可以啦 */</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span>(a[i] &gt; a[i+<span class="number">1</span>])  <span class="comment">/* 把值比较大的元素沉到底 */</span></span><br><span class="line">         &#123;</span><br><span class="line">            k = a[i];</span><br><span class="line">            a[i] = a[i+<span class="number">1</span>];</span><br><span class="line">            a[i+<span class="number">1</span>] = k;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u5FEB_u6392"><a href="#u5FEB_u6392" class="headerlink" title="快排"></a>快排</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*================================================</span><br><span class="line">  功能：快速排序</span><br><span class="line">  输入：数组名称（也就是数组首地址）、数组中起止元素的下标</span><br><span class="line">  ================================================*/</span></span><br><span class="line"><span class="comment">/*====================================================</span><br><span class="line">  算法思想简单描述：</span><br><span class="line"></span><br><span class="line">  快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟</span><br><span class="line">  扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次</span><br><span class="line">  扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只</span><br><span class="line">  减少1。快速排序通过一趟扫描，就能确保某个数（以它为基准点吧）</span><br><span class="line">  的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理</span><br><span class="line">  它左右两边的数，直到基准点的左右只有一个元素为止。它是由</span><br><span class="line">  C.A.R.Hoare于1962年提出的。</span><br><span class="line">  显然快速排序可以用递归实现，当然也可以用栈化解递归实现。下面的</span><br><span class="line">  函数是用递归实现的，有兴趣的朋友可以改成非递归的。</span><br><span class="line">  快速排序是不稳定的。最理想情况算法时间复杂度O(nlog2n)，最坏O(n2)</span><br><span class="line">  =====================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i, j, t;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (low &lt; high) <span class="comment">/*要排序的元素起止下标，保证小的放在左边，大的放在右边。这里以下标为low的元素为基准点*/</span></span><br><span class="line">   &#123;</span><br><span class="line">      i = low;</span><br><span class="line">      j = high;</span><br><span class="line">      t = *(x+low); <span class="comment">/*暂存基准点的数*/</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (i&lt;j) <span class="comment">/*循环扫描*/</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">while</span> (i&lt;j &amp;&amp; *(x+j)&gt;t) <span class="comment">/*在右边的只要比基准点大仍放在右边*/</span></span><br><span class="line">         &#123;</span><br><span class="line">            j--; <span class="comment">/*前移一个位置*/</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (i&lt;j) </span><br><span class="line">         &#123;</span><br><span class="line">            *(x+i) = *(x+j); <span class="comment">/*上面的循环退出：即出现比基准点小的数，替换基准点的数*/</span></span><br><span class="line">            i++; <span class="comment">/*后移一个位置，并以此为基准点*/</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span> (i&lt;j &amp;&amp; *(x+i)&lt;=t) <span class="comment">/*在左边的只要小于等于基准点仍放在左边*/</span></span><br><span class="line">         &#123;</span><br><span class="line">            i++; <span class="comment">/*后移一个位置*/</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (i&lt;j)</span><br><span class="line">         &#123;</span><br><span class="line">            *(x+j) = *(x+i); <span class="comment">/*上面的循环退出：即出现比基准点大的数，放到右边*/</span></span><br><span class="line">            j--; <span class="comment">/*前移一个位置*/</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      *(x+i) = t; <span class="comment">/*一遍扫描完后，放到适当位置*/</span></span><br><span class="line">      quick_sort(x,low,i-<span class="number">1</span>);  <span class="comment">/*对基准点左边的数再执行快速排序*/</span></span><br><span class="line">      quick_sort(x,i+<span class="number">1</span>,high);  <span class="comment">/*对基准点右边的数再执行快速排序*/</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">
<ul class="pagination">
	 
				
    	<li class="prev"><a href="/2015/12/21/python/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>上一页</a></li>
  		

        <li><a href="/archives"><i class="fa fa-archive"></i>Archive</a></li>

		
		   <li class="next"><a href="/2015/12/21/git/" class="alignright next">下一页<i class="fa fa-arrow-circle-o-right"></i></a></li>         
        
	
</ul>
</div>

    </center>
	</div>
	
	<!-- comment -->
	
<section id="comment">
  <h2 class="title">留言</h2>

  
</section>

	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2015-12-21 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/code/">code<span>2</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/c/">c<span>1</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
			<ol class="toc-article"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#u5B57_u8282_u5BF9_u9F50"><span class="toc-article-text">字节对齐</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#u6307_u9488"><span class="toc-article-text">指针</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#u6307_u9488_u7C7B_u578B"><span class="toc-article-text">指针类型</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#u6307_u9488_u8FD0_u7B97"><span class="toc-article-text">指针运算</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#u8FD0_u7B97_u7B26_26amp_3B_u548C*"><span class="toc-article-text">运算符&和*</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#u6307_u9488_u957F_u5EA6"><span class="toc-article-text">指针长度</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#u6307_u9488_u8FD0_u7B97-1"><span class="toc-article-text">指针运算</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#u6307_u9488_u548C_u6570_u7EC4"><span class="toc-article-text">指针和数组</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#u6307_u9488_u548C_u7ED3_u6784"><span class="toc-article-text">指针和结构</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#u6307_u9488_u548C_u51FD_u6570"><span class="toc-article-text">指针和函数</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#u94FE_u8868"><span class="toc-article-text">链表</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#C_u8BED_u8A00_u94FE_u8868_u7684_u4F5C_u7528_uFF1A"><span class="toc-article-text">C语言链表的作用：</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#C_u8BED_u8A00_u94FE_u8868_u7684_u6784_u6210"><span class="toc-article-text">C语言链表的构成</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#u94FE_u8868_u7684_u5206_u7C7B"><span class="toc-article-text">链表的分类</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#u94FE_u8868_u7684_u64CD_u4F5C"><span class="toc-article-text">链表的操作</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#u6392_u5E8F"><span class="toc-article-text">排序</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#u5192_u6CE1_u6392_u5E8F"><span class="toc-article-text">冒泡排序</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#u5FEB_u6392"><span class="toc-article-text">快排</span></a></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2016 wchao
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
