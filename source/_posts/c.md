title: c语言
date: 2015-12-21 14:27:28
tags: c
categories: code
toc: true 
---

### 字节对齐
```c
// 第一种
struct A
{
    char a;
    short b;
    int c;
};
sizeof(struct A) = 8;

// 第二种
struct A
{
    char a;
    int c;
    short b;
};
sizeof(struct A) = 12;
```

<!-- more -->

看图

![对齐](/images/c_align.jpg)

## 指针
### 指针类型
| 代码                 | 说明                                                                           |
|----------------------|--------------------------------------------------------------------------------|
| `int p;`             | 一个整型变量                                                                   |
| `int *p;`            | 一个指向整型数的指针                                                           |
| `int p[10];`         | 一个有10个整型数的数组                                                         |
| `int *p[10];`        | 一个有10个指针的数组，该指针是指向一个整型数的                                 |
| `int (*p)[10];`      | 一个指向有10个整型数数组的指针                                                 |
| `int **p;`           | 一个指向指针的的指针，它指向的指针是指向一个整型数                             |
| `int p(int);`        | 一个有整型参数且返回类型为整型的函数                                           |
| `int (*p)(int);`     | 一个指向函数的指针，该函数有一个整型参数并返回一个整型数                       |
| `int (*p[10])(int);` | 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数 |

### 指针运算

#### 运算符&和*

`&`是取地址运算符

`*`是书上叫做**间接运算符**

#### 指针长度

在32位系统中，指针只代表指向的值的**地址**，所以其本身的长度为4个字节，可以用**sizeof()**得出

```c
int *p;
char *p;
struct xx *p;
```

不管哪个，**sizeof(p)=4**！

#### 指针运算
```c
int *p;
p++;
```
p指向下一个单元地址，也就是把指针p的值加上了sizeof(int)，根据p指向的变量不同而不同。32位系统中，int占用4个字节，所以p的地址会加**4**

{% alert danger %}
注意：指针运算时是按p的类型长度，而不是赋值时的变量长度
{% endalert %}

### 指针和数组
```c
int array[10]={0,1,2,3,4,5,6,7,8,9};
```
一般而言，数组名可以看做指针，指向数组的第0个单元。

array+3是一个指向数组第3个单元的指针，所以*(array+3)等于3。

{% alert danger %}
与指针不同的是，数组名只能代表数组首地址，并不是一个变量，所以不是一个左值，并不能进行如 `array++` 这样的运算。
{% endalert %}

关于sizeof
* `sizeof(array)` 数组的大小， =40    （sizeof(int)*10）
* `sizeof(*array)`  数组单元的大小， =4 （sizeof(int))
* `sizeof(array+1)` 指针类型的大小， =4 （指针本身的长度，32位系统为4）

### 指针和结构
```c
struct MyStruct 
{ 
    int a; 
    int b; 
    int c; 
} 
MyStruct ss={20,30,40};     //声明了结构对象ss，并把ss的三个成员初始化为20，30和40。
MyStruct *ptr=&ss;          //声明了一个指向结构对象ss的指针。它的类型是MyStruct*,它指向的类型是MyStruct。
int *pstr=(int*)&ss;        //声明了一个指向结构对象ss的指针。但是它的类型和它指向的类型和ptr是不同的。
```

请问怎样通过指针ptr来访问ss的三个成员变量？

答案： 

> ptr->a; 
> ptr->b; 
> ptr->c; 

### 指针和函数

--------------------------------------

## 链表

### C语言链表的作用：

* 实现内存的动态分配
* 实现内存数据的不连续存储
 
### C语言链表的构成
```c
struct node
{
   int a;
   struct node *next;
}
```

链表是由节点组成，所谓节点就是指一个结构体，这个结构体主要包括两部分：**数据域** 和 **指针域**。指针域用来指向下一个节点的首地址。

首节点：

尾节点：尾节点指针域指向NULL。

### 链表的分类

链表主要分为三种：单链表；双链表；循环链表

### 链表的操作

链表的操作主要包括：

* 链表的创建
* 链表的删除
* 链表的插入

下面以单链表为例讲述这三种链表的操作：

* 链表的创建
 
```c
#include <stdio.h>
struct chain
{
   int value;           //数据域
   struct chain *next;  //指针域
}

struct chain *create()
{
   struct chain *head,*tail,*p;     //头节点、尾节点、创建节点
   int x;
   head=tail=NULL;                  //指针初始化NULL
   printf("Input data \n");
   while(scanf("%d",&x)==1)
   {
      p=(struct chain *)malloc(sizeof(struct chain));
      p->value=x;
      p->next=NULL;
      if(head==NULL)
      {
          //初始链表里没有元素时
          head=tail=p;
      }
      else
      {
         // 又有一个了
         tail=tail->next;           //把尾部指向上一个
         tail->next=p;              //把p挂在最后面，变成新的尾部
      }
   }
   return head;
}

void main()
{
   struct chain *p,*q;
   q=creat();
   while(q)
   {
      p=q->next;
      free(q);
      q=p;
   }
}
```

* 链表的删除，本例是删除数据域为a的链表
 
```c
struct chain *DelNode(head,a)
{
   struct chain *p,*q;
   if(head==NULL)
   {printf("this is a Empty link!")}
   else if(head->value==a)
   {
      //如果是第一个
      p=head;
      head=head->next;
   }
   else
   {
      p=head;
      while((p->value!=a)&&(p->next!=NULL))
      {
         q=p;           //找到时，q是上一个
         p=p->next;
      }
      if(p->value==a)
      {
         p=p->next;     //p是要找的，此时将p指向下一个，准备清空找到的这个
         q->next=p;     //上一个的下一个指向p，其实就是把中间一个跳过去了
         free(p);       //释放的哪一个？？？
      }
   }
}
```

* 链表的插入
 
链表的插入分三种情况：将节点插到链表的头；将节点插到链表的中间；将节点插到链表的尾。

```c
#include <stdio.h>
struct chain
{
   int value;           //数据域
   struct chain *next;  //指针域
}

struct chain *insertNode(head,a,b)   //head为头节点，a,b均为数据域,a为插入地方的节点数据域，b为新插入节点的数据域
{
   struct chain *p,*q,*s;
   s=(struct chain *)malloc(sizeof(struct chain));
   s->value=b;
   if(head==NULL)       //判断链表是否为空链表
   {
      head=s;
      s->next=NULL;
   }
   if(head->value==a)
   {
      s->next=head;
      head=s;           //head头节点变为s，head原来的值被s链接。
   }
   else
   {
      p=head;
      while((p->value!=a)&&(p->next!=NULL))
      {
         q=p;
         p=p->next;
      } //用循环进行链表的移动
      if(p->value==a)
      {
         s->next=p;
         q->next=s;
      }
      else //将节点插入到链表的末尾
      {
         p->next=s;
         s->next=NULL;
      } 
   }
   return head;
}
```

---------------------------------------------------

## 排序
### 冒泡排序
```c
/*================================================
  功能：冒泡排序
  输入：数组名称（也就是数组首地址）、数组中元素个数
  ================================================*/
/*====================================================
  算法思想简单描述：

  在要排序的一组数中，对当前还未排好序的范围内的全部数，自上
  而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较
  小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要
  求相反时，就将它们互换。

  冒泡排序是稳定的。算法时间复杂度O(n2)--[n的平方]
  =====================================================*/

void buble_sort(int a[],int n)
{
   int i,j,k;
   for(j=0; j<n; j++)   /* 气泡法要排序n次*/
   {
      for(i=0; i<n-j; i++)  /* 值比较大的元素沉下去后，只把剩下的元素中的最大值再沉下去就可以啦 */
      {
         if(a[i] > a[i+1])  /* 把值比较大的元素沉到底 */
         {
            k = a[i];
            a[i] = a[i+1];
            a[i+1] = k;
         }
      }
   }
}
```

### 快排

```c
/*================================================
  功能：快速排序
  输入：数组名称（也就是数组首地址）、数组中起止元素的下标
  ================================================*/
/*====================================================
  算法思想简单描述：

  快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟
  扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次
  扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只
  减少1。快速排序通过一趟扫描，就能确保某个数（以它为基准点吧）
  的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理
  它左右两边的数，直到基准点的左右只有一个元素为止。它是由
  C.A.R.Hoare于1962年提出的。
  显然快速排序可以用递归实现，当然也可以用栈化解递归实现。下面的
  函数是用递归实现的，有兴趣的朋友可以改成非递归的。
  快速排序是不稳定的。最理想情况算法时间复杂度O(nlog2n)，最坏O(n2)
  =====================================================*/
void quick_sort(int *x, int low, int high)
{
   int i, j, t;

   if (low < high) /*要排序的元素起止下标，保证小的放在左边，大的放在右边。这里以下标为low的元素为基准点*/
   {
      i = low;
      j = high;
      t = *(x+low); /*暂存基准点的数*/

      while (i<j) /*循环扫描*/
      {
         while (i<j && *(x+j)>t) /*在右边的只要比基准点大仍放在右边*/
         {
            j--; /*前移一个位置*/
         }

         if (i<j) 
         {
            *(x+i) = *(x+j); /*上面的循环退出：即出现比基准点小的数，替换基准点的数*/
            i++; /*后移一个位置，并以此为基准点*/
         }

         while (i<j && *(x+i)<=t) /*在左边的只要小于等于基准点仍放在左边*/
         {
            i++; /*后移一个位置*/
         }

         if (i<j)
         {
            *(x+j) = *(x+i); /*上面的循环退出：即出现比基准点大的数，放到右边*/
            j--; /*前移一个位置*/
         }
      }

      *(x+i) = t; /*一遍扫描完后，放到适当位置*/
      quick_sort(x,low,i-1);  /*对基准点左边的数再执行快速排序*/
      quick_sort(x,i+1,high);  /*对基准点右边的数再执行快速排序*/
   }
}
```

